namespace lsst { namespace pipe { namespace tasks {
/**
\page pipeTasks_writeCmdLineTask How to write a command-line task

\section pipeTasks_writeCmdLineTask_contents Contents

- \ref pipeTasks_writeCmdLineTask_overview
- \ref pipeTasks_writeCmdLineTask_runScript
- \ref pipeTasks_writeCmdLineTask_configuration
- \ref pipeTasks_writeCmdLineTask_taskClassVariables
- \ref pipeTasks_writeCmdLineTask_taskMethods
- \ref pipeTasks_writeCmdLineTask_documentation
- \ref pipeTasks_writeCmdLineTask_persistingConfigAndMetadata
- \ref pipeTasks_writeCmdLineTask_retargetingSubtasks
- \ref pipeTasks_writeCmdLineTask_customArgumentParser
- \ref pipeTasks_writeCmdLineTask_customTaskRunner

\section pipeTasks_writeCmdLineTask_overview Overview

This document describes how to write a command-line task, which is the LSST version of a data processing
pipeline. Before reading this this document, please skim through \ref pipeBase_introduction
"pipe_base documentation" to get a basic idea of what tasks are and what classes are used to implement them.
It also helps to have a basic understanding of data repositories and how to use the butler to read and write
data (to be written; for now read existing tasks to see how it is done).

Command-line tasks are subclasses of lsst.pipe.base.cmdLineTask.CmdLineTask.
A task is launched via a runner script, which usually does no more than calls the task's
`parseAndRun` method, which parses the command line, and uses that information to run the task.
In a bit more detail, `parseAndRun`:
- Parses the command line, which includes figuring out the configuration for the task
  and which data items it should process
- Initializes the task, providing the configuration as one argument
- Calls the task's `run` method once for each data item to process

All this is described in more detail below, with heavy emphasis on a simple
example task: exampleTask.ExampleCmdLineTask.

\section pipeTasks_writeCmdLineTask_runScript Run Script

The script to run the task is usually very simple, since all it needs to do is import the
command-line task and call parseAndRun. Here is the runner script for ExampleCmdLineTask:
exampleCmdLineTask.py:
\dontinclude exampleCmdLineTask.py
\skip from lsst.pipe
\until parseAndRun

For a task that you want to be readily available, put the script into your package's `bin/` directory
and make it executable using `chmod +x`, so that it is on your $PATH when you setup your package with eups.
Our example script does not need to be so accessible, so it is placed in `examples/` instead of `bin/`.

\section pipeTasks_writeCmdLineTask_configuration Configuration

Every task requires a configuration. The configuration is created when the command line is parsed.
The configuration is also validated (to catch errors early) and frozen, to assure that the same config
is used to process each item of data.

Each task must specify its configuration as a task-specific subclass of lsst.pex.config.Config.
Configurations include user-settable parameters (e.g. number of iterations of outlier rejection)
and also the subtasks called by the top-level task (the task run by the
\ref pipeTasks_writeCmdLineTask_runScript "run script"). Subtasks are specified using a field of
type lsst.pex.config.ConfigurableField, which allows subtasks to be
\ref pipeTasks_writeCmdLineTask_retargetingSubtasks "retargeted" (replaced with a variant subtask).

Please document each field of the configuration carefully, so other users can figure out how to
configure your task.

exampleTask.ExampleCmdLineTask uses the following \ref exampleTask.ExampleCmdLineConfig "configuration class":
\dontinclude tasks/exampleTask.py
\skip class ExampleCmdLineConfig
\until end ExampleCmdLineConfig

The configuration class is specified as a \ref pipeTasks_writeCmdLineTask_taskClassVariables
"task class variable" `ConfigClass`.

\section pipeTasks_writeCmdLineTask_taskClassVariables Task Class Variables

Tasks require several class variables to function:
- `ConfigClass: the config class used by the task.

- `_DefaultName: a string used as the default name for the task. This is required for a command-line task,
    and strongly recommended for subtasks because it makes them easier to construct for unit tests.
    Note that when a parent task creates a subtask, it ignores the subtask's `_DefaultName` and assigns
    the name of the config parameter as the subtask's name. For example
    exampleTask.ExampleCmdLineConfig creates the statistics subtask with name "stats"
    because the config field for that subtask is `stats = lsst.pex.config.ConfigurableField(...)`.

    Task names are used for several things, including the hierarchy of task and subtask metadata,
    and (in the case of the top-level command-line task) as a component of the of the dataset type for
    saving the task's configuration and metadata.

- `TaskRunner: a class used to run the script, once the command-line has been parsed.
    The default task runner will work for any script whose `run` method accepts a single
    data reference. If your task needs something else then you will have to provide a
    \ref pipeTasks_writeCmdLineTask_customTaskRunner "custom task runner".

Here are the class variables for exampleTask.ExampleCmdLineTask (including one used internally
to support the raiseEveryN configuration parameter).
\dontinclude tasks/exampleTask.py
\skip class ExampleCmdLineTask
\skip ConfigClass
\until # end

\section pipeTasks_writeCmdLineTask_taskMethods Task Methods

Command-line tasks have the following important methods:
- `__init__`: construct and initialize a task and construct subtasks and a schema (if needed)
- `run`: process one item of data
- `_makeArgumentParser`: a class method that return an argument parser (subclass of
    pipe.base.argumentParser.ArgumentParser);
    the default may do; see \ref pipeTasks_writeCmdLineTask_customArgumentParser "custom argument parser"
    for more information.

These methods are described in more depth below:

\subsection pipeTasks_writeCmdLineTask_initMethod The __init__ Method

Use the `__init__` method (task constructor) to call `CmdLineTask.__init__`, make subtasks, make a table
schema if your task uses an afw table, and initialize any other instance variables your task needs.

Here is exampleTask.ExampleCmdLineTask.__init__:
\dontinclude tasks/exampleTask.py
\skip class ExampleCmdLineTask
\skip def \_\_init\_\_
\until # end

That task creates a `stats` subtask to compute image statistics.
Here is the \_\_init\_\_ method for the default version of the `stats` subtask:
exampleTask.ExampleSigmaClippedStatsTask, which is slightly more interesting:
\dontinclude tasks/exampleTask.py
\skip class ExampleSigmaClippedStatsTask
\skip def \_\_init\_\_
\until # end
This creates a binary mask identifying bad pixels in the mask plane
and an lsst.afw.math.StatisticsControl, specifying how statistics are computed.
Both of these are constants, and thus are the same for each invocation of the `run` method;
this is strongly recommended, as explained in the next section.

See pipe.tasks.calibrate.CalibrateTask for an example of a task that uses an afw table,
and thus must set up a schema.

\subsection pipeTasks_writeCmdLineTask_runMethod The run Method

The `run` method is a command-line task's the main entry point for processing data.
By default, your task's `run` methods will receive one argument: a data reference
for a single raw or calibrated image. If your task needs something else then you must supply a
a \ref pipeTasks_writeCmdLineTask_customArgumentParser "custom argument parser" and possibly a 
\ref pipeTasks_writeCmdLineTask_customTaskRunner "custom task runner".

Your task may supply additional methods that do much of the work of processing the data.
Breaking the work into logical pieces, each handled by a separate method, will allow
your task to be more easily adapted: a subclass can override just a few methods.

We strongly recommend that you make your task stateless, by not using instance variables
as part of your data processing. Pass data between methods by calling and returning it.
This makes the task much easier to reason about, since processing one item of data
cannot affect future items of data.

The `run` method should always return its results in an lsst.pipe.base.struct.Struct object,
with a named field for each item of data. This is safer than returning a tuple of items,
and allows adding fields without affecting existing code. Other methods should also
return Structs if they return more than one or two items.

Any method that is likely to take significant time or memory should be preceded by this python decorator:
<code>\@lsst.pipe.base.timeMethod</code>. This automatically records the execution time and memory
of the method in the task's `metadata` attribute.

The example exampleTask.ExampleCmdLineTask is so simple that it needs no other methods;
`run` does everything:
\dontinclude tasks/exampleTask.py
\skip class ExampleCmdLineTask
\skip # start run
\until # end run

The statistics are actually computed by the `stats` subtask. Here is the run method for the default
version of that task: exampleTask.ExampleSigmaClippedStatsTask.run:
\dontinclude tasks/exampleTask.py
\skip class ExampleSigmaClippedStatsTask
\skip # start run
\until # end run

\section pipeTasks_writeCmdLineTask_readWriteData Reading and Writing Data

The \ref pipeTasks_writeCmdLineTask_runMethod "run method" typically receives a single data reference, as
mentioned above. It read and writes data using this data reference (or the underlying butler, if necessary).

\anchor pipeTasks_writeCmdLineTask_addDatasetType Every time you write a task that writes a new kind of data
to the data butler (a new "dataset type") you must tell the butler about it. This is done by editing
the mapper configuration file for each obs_* package whose data the task can be run on. For instance
the configuration for the lsstSim mapper is defined in obs_lsstSim/policy/LsstSimMapper.paf.
Warning: there are plans to rewrite how mappers are configured, so this information may be outdated.

In addition, if you write a new task for which you want to save configuration and metadata
(which is the case for most tasks that process data, rather than simply report on data),
you will have to add dataset types to each obs_*'s mapper for the task's configuration and metadata,
as explained in \ref pipeTasks_writeCmdLineTask_persistingConfigAndMetadata.

If the task is of general interest (wanted for most or all obs_* packackages)
then this process of updating all the mapper configs can be fairly time consuming.

\section pipeTasks_writeCmdLineTask_documentation Task Documentation

Please read the source code for \link pipe/tasks/exampleTask.py\endlink for a documentation template.

Use """! instead of """ to start doc strings (i.e. including an exclamation mark). This causes
Doxygen to parse Doxygen commands in the doc string, which is almost always what you want.

By including a section such as the following your task's documentation will appear on the
page of \ref LSST_task_documentation, even if your task is not in the pipe_tasks package:
\code
## \addtogroup LSST_task_documentation
## \{
## \page exampleTask
## \ref ExampleCmdLineTask "ExampleCmdLineTask"
##      An example intended to show how to write a command-line task.
## \}
\endcode

\section pipeTasks_writeCmdLineTask_persistingConfigAndMetadata Persisting Task Config and Metadata

Normally when you run a task you want the configuration for the task and the metadata generated by the task
to be saved to the data repository. By default, this is done automatically, using dataset types:
- <i>_DefaultName</i>`_config` for the configuration
- <i>_DefaultName</i>`_metadata` for the metadata

Whether you use these default dataset types or \ref pipeTasks_writeCmdLineTask_customzeConfigDatasetType
"customize the dataset types", you will have to \ref pipeTasks_writeCmdLineTask_addDatasetType "add dataset
types" for the configuration and metadata.

\subsection pipeTasks_writeCmdLineTask_customzeConfigDatasetType Customizing Config and Metadata Dataset Types

Occasionally the default dataset types for configuration and metadata are not sufficient. For instance
in the case of the pipe.tasks.MakeSkyMapTask and various coaddition tasks, the coadd type must be part of
the config and metadata dataset type name. To customize the dataset type of a task's config or metadata,
define task methods _getConfigName and _getMetadataName to return the desired names. For an example see
pipe.tasks.MakeSkyMapTask._getConfigName and pipe.tasks.MakeSkyMapTask._getMetadataName.

\subsection pipeTasks_writeCmdLineTask_preventSavingConfig Prevent Saving Config and Metadata

For some tasks you may wish to not save config and metadata at all. This is appropriate for tasks that
simply report information without saving data, such as pipe_tasks/bin/reportTaskTiming.py. To disable saving
configuration and metadata define task methods `_getConfigName` and `_getMetadataName` methods to return
`None`.

\section pipeTasks_writeCmdLineTask_retargetingSubtasks Retargeting Subtasks

You may replace one subtask with another; this is called "retargeting" the subtask.
One common use case is to use a camera-specific variant of a subtask (e.g. a special version for Suprime-Cam).
Examples include:
- lsst.obs.subaru.isr.SuprimeCamIsrTask: a version of instrument signature removal (ISR or detrending)
    for Suprime-Cam and Hyper Suprime-Cam
- lsst.obs.sdss.selectSdssImages.SelectSdssImagesTask: an version of the task that selects images
    for coaddition of SDSS stripe 82 images

To retarget a task requires a config override file. For example the following will retarget
exampleTask.ExampleCmdLineTask `stats` subtask with a simpler version:
<pre>
    from lsst.pipe.tasks.exampleTask import ExampleSimpleStatsTask
    root.stats.retarget(ExampleSimpleStatsTask)
</pre>
This imports the desired variant task and retargets the config field that specifies the subtask
("root" is the same as the task's `self.config`).

To load use the above config override file for our example task, save the two lines to a file named
`override.py` and load it by specifying `--configfile=exampleOverride` on the command line.

To automatically load a config override file whenever a task is run on data from a particular camera,
give the override file the name name as the task's `_DefaultName` with suffix `.py` and put it in
obs_X/config (for all cameras at observatory X) or obs_X/Y/config (for camera Y at observatory X).
The following existing config override files should give the idea:
- obs_lsstSim/config/makeCoaddTempExp.py: specifies which version of the image selector task to use
    for coadding LSST simulated images
- obs_subaru/config/hsc/isr.py: overrides for the ISR (instrument signature removal, aka detrending)
    task for Hyper Suprime-Cam


\section pipeTasks_writeCmdLineTask_customArgumentParser Custom Argument Parser

The default argument parser returned by base.cmdLineTask.CmdLineTask._makeArgumentParser
assumes that your task's `run` method processes raw or calibrated images. If this is not the case
you can easily provide a modified argument parser by overriding the `_makeArgumentParser` method.

Here are some examples:
- A task's `run` methd requires a data reference of some kind other than an image.
    This is by a common case, and easily solved. For example the processCoadd.ProcessCoaddTask
    processes coadd patches. processCoadd.ProcessCoaddTask._makeArgumentParser is very simple:
    \dontinclude processCoadd.py
    \skipline classmethod
    \skip def _makeArgumentParser
    \until return
- A task's `run` method requires more than one kind of data reference. An example is coaddition,
    which requires the user to specify a sky map patch for the piece of coadd, and optionally allows the user
    to specify a list of exposures to coadd. coaddBase.CoaddBaseTask._makeArgumentParser is a
    straightfoward example of specifying two kinds of data IDs: one for the sky map patch,
    and the optional IDs of which exposures to coadd:
    \dontinclude coaddBase.py
    \skipline classmethod
    \skip def _makeArgumentParser
    \until return
- A task's `run` method requires no data references at all. An example is makeSkyMap.MakeSkyMapTask,
    which makes a skymap.SkyMap for a set of coadds.
    makeSkyMap.MakeSkyMapTask._makeArgumentParser is trivial:
    \dontinclude makeSkyMap.py
    \skipline classmethod
    \skip def _makeArgumentParser
    \until return

Note that if your task requires a custom argument parser to do more than just change the
type of the single data reference, then it also require a \ref pipeTasks_writeCmdLineTask_customTaskRunner
"custom task runner", as well (see next section).

\section pipeTasks_writeCmdLineTask_customTaskRunner Custom Task Runner

The standard task runner is lsst.pipe.base.task.TaskRunner. It assumes that your task's `run` method
wants a single data reference and nothing else. If that is not the case then you will have to provide
a custom task runner (subclass of lsst.pipe.base.task.TaskRunner).

Here are some situations where a custom task runner is required:
- The task's `run` method requires extra arguments. An example is coaddition, which optionally accepts
    a list of calexp to coadd. The custom task runner is coaddBase.CoaddTaskRunner and is pleasantly simple.
    \dontinclude coaddBase.py
    \skip class CoaddTaskRunner
    \until end CoaddTaskRunner
- The task requires no data references, just a butler. An example is makeSkyMap.MakeSkyMapTask,
    which makes a skymap.SkyMap for a set of coadds. It uses the custom task runner
    makeSkyMap.MakeSkyMapRunner, which is more complicated than the previous example
    because the entire `__call__` method must be overridden.
    \dontinclude makeSkyMap.py
    \skip class MakeSkyMapRunner
    \until end MakeSkyMapRunner

*/
}}} // namespace lsst::pipe::tasks