namespace lsst { namespace pipe { namespace tasks {
/**
\page pipeTasks_writeCmdLineTask How to Write a Command-Line Task

The exciting sequel to \ref pipeTasks_writeTask

\section pipeTasks_writeCmdLineTask_contents Contents

- \ref pipeTasks_writeCmdLineTask_overview
    - \ref pipeTasks_writeCmdLineTask_differences
- \ref pipeTasks_writeCmdLineTask_runScript
- \ref pipeTasks_writeCmdLineTask_differences
- \ref pipeTasks_writeCmdLineTask_documentation
- \ref pipeTasks_writeCmdLineTask_readWriteData
- \ref pipeTasks_writeCmdLineTask_persistingConfigAndMetadata
    - \ref pipeTasks_writeCmdLineTask_customzeConfigDatasetType
    - \ref pipeTasks_writeCmdLineTask_preventSavingConfig
- \ref pipeTasks_writeCmdLineTask_retargetingSubtasks
- \ref pipeTasks_writeCmdLineTask_customArgumentParser
- \ref pipeTasks_writeCmdLineTask_customTaskRunner

\section pipeTasks_writeCmdLineTask_overview Overview

This document describes how to write a command-line task, which is the LSST version of a complete
data processing pipeline.Before reading this manual it helps to understand:
- \ref pipeTasks_writeTask. A command-line task is an enhanced version of a regular task.
    Thus all the considerations for writing a normal task also apply to writing a command-line task,
    and these will not be repeated in this manual.
- \ref pipeBase_introduction "pipe_base documentation" to get a basic idea of what tasks are
    and what classes are used to implement them.
- \ref A basic understanding of data repositories and how to use the butler to read and write data
    (to be written; for now read existing tasks to see how it is done).

\subsection pipeTasks_writeCmdLineTask_differences Differences between Tasks and Command-Line Tasks

A command-line task is an enhanced version of a regular task.
Regular tasks are only intended to be used as stages in data processing pipelines,
whereas command-line tasks can also be used as complete pipelines. As such,
command-line tasks include \ref pipeTasks_writeCmdLineTask_runScript that run them as pipelines.

Command-line tasks are subclasses of lsst.pipe.base.cmdLineTask.CmdLineTask,
whereas ordinary tasks are subclasses of lsst.pipe.base.Task.Task,

Command-line tasks always have a `run` method which performs the full pipeline data processing.
By default a command-line task's `run` method takes exactly one argument: a data reference
for the item of data to be processed. Variations are possible, but require that you provide
a pipeTasks_writeCmdLineTask_customArgumentParser and often a pipeTasks_writeCmdLineTask_customTaskRunner.

When run from the command line, most command-line tasks will save the configuration used to run
the task and the metadata generated while running the task. This information is saved to the
output data repository. The default dataset type for the config is `<defaultName>_config`
and the metdata is `<defaultName>_metadata`, where `<defaultName>` is the value of
the task's `_DefaultName` class variable. To change these names or disable saving of
config and/or metdata, see \ref pipeTasks_writeCmdLineTask_persistingConfigAndMetadata.

Command-line tasks have one additional required \ref pipeTasks_writeTask_classVariables "class variable":
`TaskRunner: a class used to run the script, once the command-line has been parsed.
The default task runner will work for any script whose `run` method accepts a single
data reference, such as ExampleCmdLineScript. If your task's `run` method needs something else
then you will have to provide a \ref pipeTasks_writeCmdLineTask_customTaskRunner "custom task runner".

\section pipeTasks_writeCmdLineTask_runScript Run Script

A command-line task can be run as a pipeline via run script. This is usually a trivial script
which merely calls the task's `parseAndRun` method. `parseAndRun` does the following:
- Parses the command line, which includes figuring out the configuration for the task
  and which data items the task should process.
- Constructs the task.
- Calls the task's `run` method once for each data item to process.

The runner script for ExampleCmdLineTask is examples/exampleCmdLineTask.py:
\dontinclude exampleCmdLineTask.py
\skip from lsst.pipe
\until parseAndRun

For mosts command-line tasks you should put the run script into your package's `bin/` directory,
so that it is on your `$PATH` when you setup your package with eups. We did not want the run script
for ExampleCmdLineTask to be quite so accessible, so we placed it in the `examples/` directory
instead of `bin/`.

Don't forget to and your run script executable using `chmod +x`.

\section pipeTasks_writeCmdLineTask_readWriteData Reading and Writing Data

The \ref pipeTasks_writeCmdLineTask_runMethod "run method" typically receives a single data reference, as
mentioned above. It read and writes data using this data reference (or the underlying butler, if necessary).

\anchor pipeTasks_writeCmdLineTask_addDatasetType Every time you write a task that writes a new kind of data
to the data butler (a new "dataset type") you must tell the butler about it. This is done by editing
the mapper configuration file for each obs_* package whose data the task can be run on. For instance
the configuration for the lsstSim mapper is defined in obs_lsstSim/policy/LsstSimMapper.paf.
Warning: there are plans to rewrite how mappers are configured, so this information may be outdated.

In addition, if you write a new task for which you want to save configuration and metadata
(which is the case for most tasks that process data, rather than simply report on data),
you will have to add dataset types to each obs_*'s mapper for the task's configuration and metadata,
as explained in \ref pipeTasks_writeCmdLineTask_persistingConfigAndMetadata.

If the task is of general interest (wanted for most or all obs_* packackages)
then this process of updating all the mapper configs can be fairly time consuming.

\section pipeTasks_writeCmdLineTask_documentation Task Documentation

Please read the source code for \link pipe/tasks/exampleTask.py\endlink for a documentation template.

Use """! instead of """ to start doc strings (i.e. including an exclamation mark). This causes
Doxygen to parse Doxygen commands in the doc string, which is almost always what you want.

By including a section such as the following your task's documentation will appear on the
page of \ref LSST_task_documentation, even if your task is not in the pipe_tasks package:
\code
## \addtogroup LSST_task_documentation
## \{
## \page exampleTask
## \ref ExampleCmdLineTask "ExampleCmdLineTask"
##      An example intended to show how to write a command-line task.
## \}
\endcode

\section pipeTasks_writeCmdLineTask_persistingConfigAndMetadata Persisting Config and Metadata

Normally when you run a task you want the configuration for the task and the metadata generated by the task
to be saved to the data repository. By default, this is done automatically, using dataset types:
- <i>_DefaultName</i>`_config` for the configuration
- <i>_DefaultName</i>`_metadata` for the metadata

Whether you use these default dataset types or \ref pipeTasks_writeCmdLineTask_customzeConfigDatasetType
"customize the dataset types", you will have to \ref pipeTasks_writeCmdLineTask_addDatasetType "add dataset
types" for the configuration and metadata.

\subsection pipeTasks_writeCmdLineTask_customzeConfigDatasetType Customizing Config and Metadata Dataset Types

Occasionally the default dataset types for configuration and metadata are not sufficient. For instance
in the case of the \ref pipe.tasks.makeSkyMap.MakeSkyMapTask "pipe.tasks.MakeSkyMapTask"
and various coaddition tasks, the coadd type must be part of the config and metadata dataset type name.
To customize the dataset type of a task's config or metadata, define task methods _getConfigName and
_getMetadataName to return the desired names.

\subsection pipeTasks_writeCmdLineTask_preventSavingConfig Prevent Saving Config and Metadata

For some tasks you may wish to not save config and metadata at all. This is appropriate for tasks that
simply report information without saving data, such as pipe_tasks/bin/reportTaskTiming.py. To disable saving
configuration and metadata define task methods `_getConfigName` and `_getMetadataName` methods to return
`None`.

\section pipeTasks_writeCmdLineTask_retargetingSubtasks Retargeting Subtasks

You may replace one subtask with another; this is called "retargeting" the subtask.
One common use case is to use a camera-specific variant of a subtask (e.g. a special version for Suprime-Cam).
Examples include:
- lsst.obs.subaru.isr.SuprimeCamIsrTask: a version of instrument signature removal (ISR or detrending)
    for Suprime-Cam and Hyper Suprime-Cam
- lsst.obs.sdss.selectSdssImages.SelectSdssImagesTask: an version of the task that selects images
    for coaddition of SDSS stripe 82 images

To retarget a task requires a config override file. For example the following will retarget
exampleTask.ExampleCmdLineTask `stats` subtask with a simpler version:
<pre>
    from lsst.pipe.tasks.exampleTask import ExampleSimpleStatsTask
    root.stats.retarget(ExampleSimpleStatsTask)
</pre>
This imports the desired variant task and retargets the config field that specifies the subtask
("root" is the same as the task's `self.config`).

To load use the above config override file for our example task, save the two lines to a file named
`override.py` and load it by specifying `--configfile=exampleOverride` on the command line.

To automatically load a config override file whenever a task is run on data from a particular camera,
give the override file the name name as the task's `_DefaultName` with suffix `.py` and put it in
obs_X/config (for all cameras at observatory X) or obs_X/Y/config (for camera Y at observatory X).
The following existing config override files should give the idea:
- obs_lsstSim/config/makeCoaddTempExp.py: specifies which version of the image selector task to use
    for coadding LSST simulated images
- obs_subaru/config/hsc/isr.py: overrides for the ISR (instrument signature removal, aka detrending)
    task for Hyper Suprime-Cam


\section pipeTasks_writeCmdLineTask_customArgumentParser Custom Argument Parser

The default argument parser returned by base.cmdLineTask.CmdLineTask._makeArgumentParser
assumes that your task's `run` method processes raw or calibrated images. If this is not the case
you can easily provide a modified argument parser by overriding the `_makeArgumentParser` method.

Here are some examples:
- A task's `run` methd requires a data reference of some kind other than an image.
    This is by a common case, and easily solved. For example the processCoadd.ProcessCoaddTask
    processes coadd patches. processCoadd.ProcessCoaddTask._makeArgumentParser is very simple:
    \dontinclude processCoadd.py
    \skipline classmethod
    \skip def _makeArgumentParser
    \until return
- A task's `run` method requires more than one kind of data reference. An example is coaddition,
    which requires the user to specify a sky map patch for the piece of coadd, and optionally allows the user
    to specify a list of exposures to coadd. coaddBase.CoaddBaseTask._makeArgumentParser is a
    straightfoward example of specifying two kinds of data IDs: one for the sky map patch,
    and the optional IDs of which exposures to coadd:
    \dontinclude coaddBase.py
    \skipline classmethod
    \skip def _makeArgumentParser
    \until return
- A task's `run` method requires no data references at all. An example is makeSkyMap.MakeSkyMapTask,
    which makes a skymap.SkyMap for a set of coadds.
    makeSkyMap.MakeSkyMapTask._makeArgumentParser is trivial:
    \dontinclude makeSkyMap.py
    \skipline classmethod
    \skip def _makeArgumentParser
    \until return

Note that if your task requires a custom argument parser to do more than just change the
type of the single data reference, then it also require a \ref pipeTasks_writeCmdLineTask_customTaskRunner
"custom task runner", as well.

\section pipeTasks_writeCmdLineTask_customTaskRunner Custom Task Runner

The standard task runner is lsst.pipe.base.task.TaskRunner. It assumes that your task's `run` method
wants a single data reference and nothing else. If that is not the case then you will have to provide
a custom task runner (subclass of lsst.pipe.base.task.TaskRunner).

Here are some situations where a custom task runner is required:
- The task's `run` method requires extra arguments. An example is coaddition, which optionally accepts
    a list of calexp to coadd. The custom task runner is coaddBase.CoaddTaskRunner and is pleasantly simple.
    \dontinclude coaddBase.py
    \skip class CoaddTaskRunner
    \until end CoaddTaskRunner
- The task requires no data references, just a butler. An example is makeSkyMap.MakeSkyMapTask,
    which makes a skymap.SkyMap for a set of coadds. It uses the custom task runner
    makeSkyMap.MakeSkyMapRunner, which is more complicated than the previous example
    because the entire `__call__` method must be overridden.
    \dontinclude makeSkyMap.py
    \skip class MakeSkyMapRunner
    \until end MakeSkyMapRunner

*/
}}} // namespace lsst::pipe::tasks